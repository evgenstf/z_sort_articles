[{
  "type":"tldr",
  "content":"**WebAssembly** *(сокр. WASM)* — технология запуска предварительно скомпилированного бинарного кода в браузере на стороне клиента. Впервые была представлена в 2015 году и на текущий момент поддерживается [большинством современных браузеров](https://caniuse.com/wasm).\n\nОдин из распространенный сценариев использования - предварительная обработка данных на стороне клиента перед отправкой файлов на сервер. В этой статье разберемся как это делается."
},
{"type":"markdown",
  "content":"# Перед началом\n \nПро архитектуру WebAssembly и общие шаги довольно подробно написано [здесь](https://habr.com/ru/post/475778/) и [тут](https://habr.com/ru/post/475778/). Мы же пройдемся только по основным фактам.\n \nРабота с WebAssembly начинается с предварительной сборки артефактов, необходимых для запуска скомпилированного кода на стороне клиента. Их два: собственно сам бинарный WASM файл и JavaScript прослойка, через которую можно вызывать <+экспортированные в него методы+>(А как их экспортировать?){Методом **cwrap**, об этом будет дальше.}.\n \nПример простейшего кода на C++ для компиляции \n```python hl_lines=\"10 10\" \n#include <algorithm>\n \nextern \"C\" {\nint calculate_gcd(int a, int b) {\n  while (a != 0 && b != 0) {\n    a %= b;\n    std::swap(a, b);\n  }\n  return a + b; \n} \n} \n```\n \nДля сборки используется [Emscripten](https://emscripten.org/docs/index.html), который кроме основного интерфейса подобных компиляторов, содержит дополнительные флаги, через которые задается конфигурация виртуальной машины и экспортируемые методы. Простейший запуск выглядит примерно так: \n``` \nem++ main.cpp --std=c++17 -o gcd.html \\ \n-s EXPORTED_FUNCTIONS='[\"_calculate_gcd\"]' \\ \n-s EXTRA_EXPORTED_RUNTIME_METHODS='[\"cwrap\"]' \n```\n \nУказанием в качестве объекта **.html** файла подсказывает компилятору, что нужно создать также простую html-разметку с js консолью. Теперь если запустить сервер на полученных файлах, увидим эту консоль с возможностью запуска **_calculate_gcd**: \n![](https://habrastorage.org/webt/f8/eu/ht/f8euhtigkftvegwdj0nycrgmumm.png)\n\n \n# Обработка данных\n \nРазберем ее на простом примере <+lz4-компрессии+>(Что это?){Алгоритм сжатия данных без потерь, ориентированный на высокую скорость сжатия и распаковки.} с помощью библиотеки, написанной на **C++**. Замечу, что на этом множество поддерживаемых языков [не заканчивается](https://github.com/appcypher/awesome-wasm-langs).\n \nНесмотря на простоту и некоторую синтетичность примера, это довольно полезная иллюстрация того, как работать с данными. Аналогичным образом над ними можно выполнять любые действия, для которых достаточно мощностей клиента: предобработка изображений перед отправкой на сервер, компрессия аудио, подсчет различных статистик и многое другое.\n \nВесь код целиком можно найти [тут](https://github.com/evgenstf/wasm_data_processing).\n \n## С++ часть\n \nИспользуем [уже готовую реализацию](https://github.com/lz4/lz4) lz4. Тогда **main** файл будет выглядеть весьма лаконично: \n``` \n#include \"lz4.h\"\n \nextern \"C\" {\n \nuint32_t compress_data(uint32_t* data, uint32_t data_size, uint32_t* result) {\n  uint32_t result_size = LZ4_compress(\n      (const char *)(data), (char*)(result), data_size); \n  return result_size; \n}\n \nuint32_t decompress_data(uint32_t* data, uint32_t data_size, \n    uint32_t* result, uint32_t max_output_size) { \n  uint32_t result_size = LZ4_uncompress_unknownOutputSize( \n     (const char *)(data), (char*)(result), data_size, max_output_size); \n  return result_size; \n}\n \n} \n```\n \nКак можно видеть, в нем просто объявлены **внешние** (используя ключевое слово `extern`) функции, внутри вызывающие соответствующие методы из библиотеки с lz4.\n \nВообще говоря, в нашем случае этот файл бесполезен: можно сразу использовать нативный интерфейс из **lz4.h**. Однако в более сложных проектах (например, объединяющих функционал разных библиотек), удобно иметь такую общую точку входа с перечислением всех используемых функций.\n \nДалее компилируем код используя уже упомянутый компилятор **Emscripten**: \n``` \nem++ main.cpp lz4.c -o wasm_compressor.js \\ \n-s EXPORTED_FUNCTIONS='[\"_compress_data\",\"_decompress_data\"]' \\ \n-s EXTRA_EXPORTED_RUNTIME_METHODS='[\"cwrap\"]' \\ \n-s WASM=1 -s ALLOW_MEMORY_GROWTH=1 \n```\n \nРазмер полученных артефактов настораживает: \n``` \n$ du -hs wasm_compressor.* \n112K    wasm_compressor.js \n108K    wasm_compressor.wasm \n```\n \nЕсли открыть JS файл-прослойку, можно увидеть примерно следующее: \n![код wasm_compress.js](https://habrastorage.org/webt/cs/8r/lx/cs8rlx29cgv0jg5ipr0l9uo5qic.png)\n \nВ ней много лишнего: от комментариев до сервисных функций, большая часть которых не используется. Ситуацию можно исправить добавлением флага `-O2`, [в Emscripten компиляторе он включает также оптимизацию js кода.](https://emscripten.org/docs/tools_reference/emcc.html#emcc-o2)\n \nПосле этого js код выглядит более приятно: \n![короткий код wasm_compress.js](https://habrastorage.org/webt/4b/hy/n7/4bhyn75qzzlw_v-clmtifvx0iza.png)\n \n## Клиентский код\n \nНужно как-то вызвать обработчик на стороне клиента. Первым делом загрузим файл, предоставленный пользователем, через `FileReader`, хранить сырые данные будем в примитиве `Uint8Array`: \n``` \nvar rawData = new Uint8Array(fileReader.result); \n```\n \nДалее нужно передать загруженные данные в виртуальную машину. Для этого сначала аллоцируем нужное количество байт методом `_malloc`, затем скопируем туда JS массив методом `set`. Для удобства выделим эту логику в функцию `arrayToWasmPtr(array)`: \n``` \nfunction arrayToWasmPtr(array) { \n  var ptr = Module._malloc(array.length); \n  Module.HEAP8.set(array, ptr); \n  return ptr; \n} \n```\n \nПосле загрузки данных в память виртуальной машины, нужно каким-то образом вызвать функцию из обработки. Но как эту функцию найти? Нам поможет метод `cwrap` - первым аргументом в нем указывается название искомой функции, вторым - возвращаемый тип, третьим - список с входными аргументами.\n```\ncompressDataFunction = Module.cwrap('compress_data', 'number', \n['number', 'number', 'number']); \n```\n \nИ наконец нужно вернуть готовые байты из виртуальной машины. Для этого пишем еще одну функцию, копирующую их в JS массив посредством метода `subarray` \n``` \nfunction wasmPtrToArray(ptr, length) { \n  var array = new Int8Array(length); \n  array.set(Module.HEAP8.subarray(ptr, ptr + length)); \n  return array; \n} \n```\n \nПолный скрипт обработки входящих файлов лежит [тут](https://github.com/evgenstf/wasm_data_processing/blob/master/lz4_compression_sample/handle_upload.js). HTML-разметка, содержащая форму загрузки файла и подгрузку wasm артефактов [здесь](https://github.com/evgenstf/wasm_data_processing/blob/master/lz4_compression_sample/index.html).\n \n## Итог\n \nПоиграться с прототипом можно [здесь](http://195.2.78.56/)\n \nВ результате получилась рабочая архивация, использующая WASM. Из минусов -- текущая реализация технологии не позволяет освобождать аллоцированную в виртуальной машине память. Это создает неявную утечку, когда загружается большое количество файлов за одну сессию, но может быть исправлено переиспользованием уже существующей памяти вместо выделения новой.\n\n\n" }]
