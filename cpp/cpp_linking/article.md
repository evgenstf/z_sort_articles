TLDR: Код на C++ можно разбивать на единицы трансляции, собирающиеся независимо, для этого существует механизм внутренних и внешних связей, называемый линковкой. Это позволяет создавать исполняемые файлы, статические и динамические библиотеки. Для удобной работы с большим количеством сущностей существуют системы сборки, например make и cmake.

[//]:<>(preview_end)

## Что это такое и зачем нужно?

Рано или поздно (чаще рано) любой проект приходит в состояние, когда весь код не умещается в один файл. На это может быть сразу несколько причин: логических сущностей становится все больше, намечается явное разделение на модули, строчек кода становится слишком много. Тогда интуитивным решением будет разделить кодовую базу на несколько файлов, объединив код в них по некоторой логике.

Следующим закономерным шагом будет не только формальное разделение на файлы, но и на отдельные таргеты компиляции, называемые *единицами трансляции*. Для удобства понимания можно считать, что это модули - атомарные подпроекты, содержащие свою более-менее независимую логику. После компиляции каждой такой сущности образуется бинарный артефакт, который можно *прилинковать* к остальным и получить конечный исполняемый файл или библиотеку.

Такое разделение на уровне компиляции дает основное преимущество модульной архитектуры по сравнению с монолитной - теперь проект можно компилировать независимо по единицам трансляции. При изменении кода, не нужно пересобирать всю кодовую базу: достаточно пересобрать единицу трансляции, к которой он относится. Это существенно экономит время сборки при разработке всего проекта.

## Как это работает в коде?

Скомпилируем простейшую программу, не использующую сторонних библиотек.

```
int main() {
	return 1;
}
```
В директории появился файл **a.out**. Это бинарный файл в формате [ELF (Executable and Linkable Format)](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format).  Для его анализа существует инструмент **readelf** - он позволяет посмотреть все низкоуровневые сущности. Однако в рамках этой статьи нас будут интересовать только сами символы. Утилита **mcview** умеет удобно парсить elf и показывать их список:

![](https://habrastorage.org/webt/gf/zf/3n/gfzf3ngekobjqrcvu5h4pveyv6m.png)Большая часть скомпилированного файла состоит из служебных символов. Нас интересует только **main**.

Теперь попробуем добавить в программу функцию, и сразу увидим, что в elf артефакте появился новый символ с ее названием:

```
double average(int a, int b) {
	return static_cast<double>(a + b) / 2.0;
}
int main() {
	int a = 10;
	int b = 20;
	return static_cast<int>(average(a, b));
}
```
![](https://habrastorage.org/webt/ve/tm/vp/vetmvpbfoox4lsqypk6x9obrvmi.png)

Далее попробуем вынести эту функцию в отдельную единицу трансляции. Для этого создадим рядом файл average.cpp с ней:
```
double average(int a, int b) {
	return  static_cast<double>(a + b) / 2.0;
}
```
А в main.cpp уберем определение функции и оставим только объявление:
```
double average(int a, int b);

int main() {
	int a = 10;
	int b = 20;
	return  static_cast<int>(average(a, b));
}
```

Теперь если собрать average.cpp как <!объектный файл!>(Какой командой?){g++ -c average.cpp}, образуется объектный файл average.o, который содержит только этот символ:
![](https://habrastorage.org/webt/dv/h9/d7/dvh9d7fqralg6ep3qmmf9nzvkui.png)

Наконец, мы можем <!собрать!>(Какой командой?){g++ main.cpp average.o} его вместе с основным main-ом в исполняемый файл.


