[{
  "type": "tldr",
  "content": "Код на C++ можно разбивать на единицы трансляции, собирающиеся независимо, для этого существует механизм внутренних и внешних связей, называемый линковкой. Это позволяет создавать исполняемые файлы, статические и динамические библиотеки. Для удобной работы с большим количеством сущностей существуют системы сборки, например make и cmake."
},
{
  "type": "markdown",
  "content": "## Что это такое и зачем нужно?\n\nРано или поздно (чаще рано) любой проект приходит в состояние, когда весь код не умещается в один файл. На это может быть сразу несколько причин: логических сущностей становится все больше, намечается явное разделение на модули, строчек кода становится слишком много. Тогда интуитивным решением будет разделить кодовую базу на несколько файлов, объединив код в них по некоторой логике.\n\nСледующим закономерным шагом будет не только формальное разделение на файлы, но и на отдельные таргеты компиляции, называемые *единицами трансляции*. Для удобства понимания можно считать, что это модули - атомарные подпроекты, содержащие свою более-менее независимую логику. После компиляции каждой такой сущности образуется бинарный артефакт, который можно *прилинковать* к остальным и получить конечный исполняемый файл или библиотеку.\n\nТакое разделение на уровне компиляции дает основное преимущество модульной архитектуры по сравнению с монолитной - теперь проект можно компилировать независимо по единицам трансляции. При изменении кода, не нужно пересобирать всю кодовую базу: достаточно пересобрать единицу трансляции, к которой он относится. Это существенно экономит время сборки при разработке всего проекта.\n\n"
},
{
  "type":"markdown",
  "content":"## Как это работает в коде?\n\nСкомпилируем простейшую программу, не использующую сторонних библиотек.\n\n```\nint main() {\n  return 1;\n}\n```\n\nВ директории появился файл **a.out**. Это бинарный файл в формате [ELF (Executable and Linkable Format)](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format).  Для его анализа существует инструмент **readelf** - он позволяет посмотреть все низкоуровневые сущности. Однако в рамках этой статьи нас будут интересовать только сами символы. Утилита **mcview** умеет удобно парсить elf и показывать их список:\n\n![](https://habrastorage.org/webt/gf/zf/3n/gfzf3ngekobjqrcvu5h4pveyv6m.png)Большая часть скомпилированного файла состоит из служебных символов. Нас интересует только **main**.\n\n Теперь попробуем добавить в программу функцию, и сразу увидим, что в elf артефакте появился новый символ с ее названием:\n\n```\ndouble average(int a, int b) {\n  return static_cast<double>(a + b) / 2.0;\n}\n\nint main() {\n  int a = 10;\n  int b = 20;\n  return static_cast<int>(average(a, b));\n}\n```\n\n![](https://habrastorage.org/webt/ve/tm/vp/vetmvpbfoox4lsqypk6x9obrvmi.png)"
},
{
  "type":"markdown",
  "content":"Далее попробуем вынести эту функцию в отдельную единицу трансляции. Для этого создадим рядом файл average.cpp с ней:\n```\ndouble average(int a, int b) {\n return  static_cast<double>(a + b) / 2.0;\n}\n```\nА в main.cpp уберем определение функции и оставим только объявление:\n```\ndouble average(int a, int b);\n\nint main() {\nint a = 10;\nint b = 20;\nreturn  static_cast<int>(average(a, b));\n}\n```\n\nТеперь если собрать average.cpp как <!объектный файл!>(Какой командой?){g++ -c average.cpp}, образуется объектный файл average.o, который содержит только этот символ:\n![](https://habrastorage.org/webt/dv/h9/d7/dvh9d7fqralg6ep3qmmf9nzvkui.png)\n\nНаконец, мы можем <!собрать!>(Какой командой?){g++ main.cpp average.o} его вместе с основным main-ом в исполняемый файл.\n\n## Статические и динамические библиотеки\n\nЛогичным развитием идеи обобщения и переиспользования кода будет распространение прекомпилированных объектных файлов для линковки их в сторонних проектах.\n\nДля этого в C++ существует концепция статических и динамических библиотек. Начнем с первых.\n\nСтатические библиотеки - это все те же объектные файлы, сопровождаемые заголовочными .h файлами. Чтобы подключить такую библиотеку в коде, нужно импортировать заголовочный файл и при компиляции в качестве объектных файлов для линковщика указать объектный файл библиотеки.\n\nДинамические библиотеки отличаются от статических тем, что использующий их код собирается без них, и вся библиотечная логика вызывается на стороне клиента уже при запуске."
},
{
  "type":"markdown",
  "content":"## CMake\n\nСпособ сборки проектных таргетов через вызов нативных команд компилятора с указанием всего списка используемых объектных файлов и исходных кодов по <!очевидным причинам!>(Все-таки каким?){Для каждого файла нужно следить к какому таргету он относится и от каких зависит. Даже для проекта среднего размера держать эту неявную логику зависимостей в голове невозможно.} неудобен.\n\nДля хранения информации о зависимостях между проектными сущностями и эффективной компиляции таргетов существуют различные системы сборки. Одной из самых распространенных, удобных и простых является **[CMake](https://cmake.org/cmake/help/latest/guide/tutorial/index.html)**.\n\nЕго базовый синтаксис довольно прост и основан на механизме уже упомянутых *таргетов* - единиц компиляции: \n``` \ncmake_minimum_required(**VERSION** 2.8) \nproject(sample_4) \nset(CMAKE_CXX_FLAGS \n\"${CMAKE_CXX_FLAGS} -std=c++11 -Wall\")\n \nset(AVERAGE_SOURCE average.cpp) \nadd_library(AVERAGE average.cpp)\n \nset(MAIN_SOURCE main.cpp) \nadd_executable(MAIN main.cpp)\n \ntarget_link_libraries(MAIN AVERAGE) \n``` \nВ коде выше создается два таргета: **AVERAGE** - библиотека, содержащая функцию вычисления среднего значения и **MAIN** - собственно исполняемый файл, вызывающий эту функцию.\n \nПоследняя строчка обозначает зависимость **MAIN**  от **AVERAGE**.\n \nТеперь чтобы скомпилировать проект достаточно запустить следующие команды:\n \n```bash \nmkdir build && cd build \ncmake .. && make \n```\n \nРезультат:\n \n```txt \n$ cmake .. && make \n-- The C compiler identification is Clang 10.0.0 \n-- The CXX compiler identification is Clang 10.0.0 \n-- Check for working C compiler: /usr/bin/clang \n-- Check for working C compiler: /usr/bin/clang -- works \n-- Detecting C compiler ABI info \n-- Detecting C compiler ABI info - done \n-- Detecting C compile features \n-- Detecting C compile features - done \n-- Check for working CXX compiler: /usr/bin/clang++ \n-- Check for working CXX compiler: /usr/bin/clang++ -- works \n-- Detecting CXX compiler ABI info \n-- Detecting CXX compiler ABI info - done \n-- Detecting CXX compile features \n-- Detecting CXX compile features - done \n-- Configuring done \n-- Generating done \n-- Build files have been written to: /home/evgenstf/z_sort_sources/cpp/cpp_linking/sample_4/build \n**Scanning dependencies of target AVERAGE** \n[ 25%] Building CXX object CMakeFiles/AVERAGE.dir/average.cpp.o \n[ 50%] **Linking CXX static library libAVERAGE.a** \n[ 50%] Built target AVERAGE \n**Scanning dependencies of target MAIN** \n[ 75%] Building CXX object CMakeFiles/MAIN.dir/main.cpp.o \n[100%] **Linking CXX executable MAIN** \n[100%] Built target MAIN \n``` \nПосле выполнения сборки в папке build появляются соответствующие артефакты **MAIN** и **libAVERAGE.a**. \n <p style='text-align: right;'> *Весь представленный в статье код можно найти в [соответствующем репозитории](https://github.com/evgenstf/z_sort_sources/tree/main/cpp/cpp_linking).* </p>\n \n \n \n"
}]
