[
{
  "type": "tldr",
  "content": "Код на C++ можно разбивать на единицы трансляции, собирающиеся независимо, для этого существует механизм внутренних и внешних связей, называемый линковкой. Это позволяет создавать исполняемые файлы, статические и динамические библиотеки. Для удобной работы с большим количеством сущностей существуют системы сборки, например make и cmake."
},
{
  "type": "markdown",
  "content": "## Что это такое и зачем нужно? \n\n  Рано или поздно (чаще рано) любой проект приходит в состояние, когда весь код не умещается в один файл. На это может быть сразу несколько причин: логических сущностей становится все больше, намечается явное разделение на модули, строчек кода становится слишком много. Тогда интуитивным решением будет разделить кодовую базу на несколько файлов, объединив код в них по некоторой логике. \n\n Следующим закономерным шагом будет не только формальное разделение на файлы, но и на отдельные таргеты компиляции, называемые *единицами трансляции*. Для удобства понимания можно считать, что это модули - атомарные подпроекты, содержащие свою более-менее независимую логику. После компиляции каждой такой сущности образуется бинарный артефакт, который можно *прилинковать* к остальным и получить конечный исполняемый файл или библиотеку. \n\n Такое разделение на уровне компиляции дает основное преимущество модульной архитектуры по сравнению с монолитной - теперь проект можно компилировать независимо по единицам трансляции. При изменении кода, не нужно пересобирать всю кодовую базу: достаточно пересобрать единицу трансляции, к которой он относится. Это существенно экономит время сборки при разработке всего проекта. \n\n## Как это работает в коде? \n\n Скомпилируем простейшую программу, не использующую сторонних библиотек. "
}
]
