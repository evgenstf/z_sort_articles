Для теоретической оценки корректности и времени выполнения алгоритмов, будем использовать строгую математическую модель алгоритмической машины **word-RAM**, на которой они запускаются. В этом конспекте разбираемся с ее формальным определением, способами оценок, разбираем на примере квадратичных сортировок.



# Устройство модели
Сначала стоит проговорить, что термин **word-RAM** расшифровывается как *word random access machine*, где *random access* означает возможность <+произвольного доступа к любой ячейки памяти+>(А бывает по-другому?){Да, например последовательная память, в которой для доступа к ячейки памяти сначала нужно прочитать все предыдущие.}, а *word* означает явное определение длины слова $w$, которым оперирует машина (например, байт -- 8 бит).

## Архитектура
Модель состоит из трех компонент:

![RAM Model Diagram]({% static 'articles/alds/ram_model/diagram_0.svg' %})

 1. **Однопоточный CPU** -- устройство, в  единственном потоке последовательно выполняющее команды.
 2. **Бесконечная одноранговая память** -- индексируемый с нуля набор ячеек, содержащих целые либо вещественные числа. Вещественные числа хранятся в экспоненциальном виде: $m \cdot 2^p$, где $m$ - мантисса числа. *Поддерживает **непрямую адресацию** -- возможность хранить в ячейке памяти указатель на другую ячейку памяти и разыменовывать его.*
 3. **Арифметико-логическое устройство (ALU)** -- в нашем контексте набор простейших арифметических операций:
	* Присутствуют всегда
		* Арифметические операции: $+, -, *, div, mod$
		* Логические операции: $<, >, ==$
	* Находятся в <+"серой зоне"+>(Что это?){Набор операций, зависящий от длины слова $w$. В некоторых задачах может быть явно запрещен. }
		* Битовые операции: $<<, >>, and, or, xor$
		* Математические операции: $sin(x), cos(y), atan2(y, x), \sqrt{x}$ ...

## Команды
Программа, исполняемая CPU может храниться отдельно от данных (так называемая [Гарвардская архитекутра](https://en.wikipedia.org/wiki/Harvard_architecture)) или же быть их частью ([архитектура Фон Неймана](https://en.wikipedia.org/wiki/Von_Neumann_architecture)).

Набор доступных команд ограничен:

* **ALU(...)** -- арифметическая операция над операндами
* **a[i]** -- обращение к памяти (разыменование $i$-ой ячейки)
* **jmp *n*** -- безусловный переход к $n$-ой команде
* **if *condition* then *n*** -- условный переход к $n$-ой команде
* **rnd *x*** -- возможность получить случайное число от $0$ до $x$

*Все операции выполняются за константное время $O(1)$*

## Ограничения используемой памяти

Главное соображение, которым мы руководствуемся вводя его, в том, чтобы алгоритм не мог использовать физическую бесконечность памяти для решения задачи.

Общее количество используемых ячеек памяти должно быть полиномиально ограниченно относительно размера входных данных.

Для этого потребуется два формальных ограничения:
* ***На размер чисел*** -- максимальное число, которое может использовать алгоритм не должно превышать полинома от
	* $C$ -- максимального числа из входных данных
	*  $n$ --  размера входных данных
	* $t(n)$ -- времени работы алгоритма (*этот компонент необходим в случаях, когда время работы превышает полином от $n$*)
* ***На ячейки памяти*** -- количество используемых ячеек памяти не должно превышать полинома от $t(n)$

# Анализ алгоритмов
Условностей выше достаточно, чтобы оценивать корректность и время работы алгоритмов.

## Оценка корректности
Три основных способа:

* Доказательство по индукции
* Доказательство по инварианту
* Доказательство от противного


## Оценка времени

 Дать оценку времени работы алгоритма $O(...)$. Также есть три способа:

* Прямой учет
* Амортизационный анализ
* Рекуррентный анализ

# На примерах квадратичных сортировок

Формально задача звучит следующим образом: дан массив из $n$ чисел, нужно отсортировать его за $O(n^2)$


TODO: здесь везде дописать оценку времени работы.
### Сортировка пузырьком
*Описание:*
Пока существуют два соседних элемента, которые нарушают порядок сортировки, алгоритм проходится по массиву от начала до конца и меняет их местами.
```
for i: 1 to n
	for j: 1 to n-1
		if a[j] > a[j + 1]
			swap(a[j], a[j + 1])
```
TODO: здесь дописать доказательство

### Сортировка выбором
*Описание:*
На $i$-ом шаге алгоритм проходится по массиву от первого элемента до элемента с индексом $n - i + 1$, выбирает из них максимальный и меняет местами с элементом с номером $n - i + 1$.
```
for i: 0 to n - 1
	p: a[p] = max(a[1], a[2], ..., a[n - i])
	swap(a[p], a[n - i])
```
*Доказательство по индукции:*

* База: $n = 1$: массив из одного элемента уже отсортирован
* Предположение: массив из $n$ элментов сортируется верно
* Переход: выберем максимальный элемент и вставим его в конец, отсортируем первые $n$ элементов, по предположению они отсортируются верно $\Rightarrow$ массив из $n + 1$ элементов будет остортирован верно.


### Сортировка вставкой
*Описание:*
Нa $i$-ом шаге первые $i$ элементов отсортированы. Рассмотрим $(i + 1)$-ый элемент и вставим его в первые $i$ элементов так, чтобы были отсортированы первые $i + 1$ элементов.

*Доказательство по инварианту:*

* Инвариант: после $i$ шагов первые $i$ элементов отсортированы
* Переход: покажем, что после $i + 1$ шага первые  $i + 1$ элементов отсортированы. Мы так вставляем $(i + 1)$-ый элемент, что инвариант сохраняется.
