<div class="article">
  <div class="article_header">Word-RAM модель. Доказательство корректности работы алгоритмов.</div>

  <div class="article_subheader"><tr>
    <table width=100% style="border-collapse:collapse"><tr>
      <td style="width:100%">
        <div class="article_parent">
          <a style="color:#283593" href=/alds>Алгоритмы и структуры данных</a>
        </div>
      </td>
      <td style="padding:0px">
        <img src="{% static "svg/clock.svg" %}" width=16px height=16px style="margin-right:10px"/>
      </td>
      <td nowrap="nowrap">
        <div class="article_reading_time">
          12 min
        </div>
      </td>
    </tr></table>
  </div>

  <div class="article_body">
    <p>Для теоретической оценки корректности и времени выполнения алгоритмов, будем использовать строгую математическую модель алгоритмической машины <strong>word-RAM</strong>, на которой они запускаются. В этом конспекте разбираемся с ее формальным определением, способами оценок, разбираем на примере квадратичных сортировок.</p><h1>Устройство модели</h1>
<p>Сначала стоит проговорить, что термин <strong>word-RAM</strong> расшифровывается как <em>word random access machine</em>, где <em>random access</em> означает возможность <span class="footnote_link" id="0" onclick='showFootnote("0")' footnote-title="А бывает по-другому?" footnote-text="<p>Да, например последовательная память, в которой для доступа к ячейки памяти сначала нужно прочитать все предыдущие.</p>">произвольного доступа к любой ячейки памяти</span class="footnote_link" id="0" onclick='showFootnote("0")' footnote-title="А бывает по-другому?" footnote-text="<p>Да, например последовательная память, в которой для доступа к ячейки памяти сначала нужно прочитать все предыдущие.</p>">, а <em>word</em> означает явное определение длины слова $w$, которым оперирует машина (например, байт -- 8 бит).</p><h2>Архитектура</h2>
<p>Модель состоит из трех компонент:</p><p><img alt="RAM Model Diagram" src="{% static 'articles/alds/ram_model/diagram_0.svg' %}" /></p><ol>
<li><strong>Однопоточный CPU</strong> -- устройство, в  единственном потоке последовательно выполняющее команды.</li>
<li><strong>Бесконечная одноранговая память</strong> -- индексируемый с нуля набор ячеек, содержащих целые либо вещественные числа. Вещественные числа хранятся в экспоненциальном виде: $m \cdot 2^p$, где $m$ - мантисса числа.
 <em>Поддерживает </em><em>непрямую адресацию</em><em> -- возможность хранить в ячейке памяти указатель на другую ячейку памяти и разыменовывать его.</em></li>
<li><strong>Арифметико-логическое устройство (ALU)</strong> -- в нашем контексте набор простейших арифметических операций:<ul>
<li>Присутствуют всегда<ul>
<li>Арифметические операции: $+, -, *, div, mod$</li>
<li>Логические операции: $&lt;, &gt;, ==$</li>
</ul>
</li>
<li>Находятся в <span class="footnote_link" id="1" onclick='showFootnote("1")' footnote-title="Что это?" footnote-text="<p>Набор операций, зависящий от длины слова $w$. В некоторых задачах может быть явно запрещен. </p>">"серой зоне"</span class="footnote_link" id="1" onclick='showFootnote("1")' footnote-title="Что это?" footnote-text="<p>Набор операций, зависящий от длины слова $w$. В некоторых задачах может быть явно запрещен. </p>"><ul>
<li>Битовые операции: $&lt;&lt;, &gt;&gt;, and, or, xor$</li>
<li>Математические операции: $sin(x), cos(y), atan2(y, x), \sqrt{x}$ ...</li>
</ul>
</li>
</ul>
</li>
</ol><h2>Команды</h2>
<p>Программа, исполняемая CPU может храниться отдельно от данных (так называемая <a href="https://en.wikipedia.org/wiki/Harvard_architecture">Гарвардская архитекутра</a>) или же быть их частью (<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">архитектура Фон Неймана</a>).</p><p>Набор доступных команд ограничен:</p><ul>
<li><strong>ALU(...)</strong> -- арифметическая операция над операндами</li>
<li><strong>a[i]</strong> -- обращение к памяти (разыменование $i$-ой ячейки)</li>
<li><strong>jmp <em>n</em></strong> -- безусловный переход к $n$-ой команде</li>
<li><strong>if <em>condition<em> then </em>n</em></strong> -- условный переход к $n$-ой команде</li>
<li><strong>rnd <em>x</em></strong> -- возможность получить случайное число от $0$ до $x$</li>
</ul><p><em>Все операции выполняются за константное время $O(1)$</em></p><h2>Ограничения используемой памяти</h2><p>Главное соображение, которым мы руководствуемся вводя его, в том, чтобы алгоритм не мог использовать физическую бесконечность памяти для решения задачи.</p><p>Общее количество используемых ячеек памяти должно быть полиномиально ограниченно относительно размера входных данных.</p><p>Для этого потребуется два формальных ограничения:</p><ul>
<li><strong><em>На размер чисел</em></strong> -- максимальное число, которое может использовать алгоритм не должно превышать полинома от<ul>
<li>$C$ -- максимального числа из входных данных</li>
<li>$n$ --  размера входных данных</li>
<li>$t(n)$ -- времени работы алгоритма (<em>этот компонент необходим в случаях, когда время работы превышает полином от $n$</em>)</li>
</ul>
</li>
<li><strong><em>На ячейки памяти</em></strong> -- количество используемых ячеек памяти не должно превышать полинома от $t(n)$</li>
</ul><h1>Анализ алгоритмов</h1>
<p>Условностей выше достаточно, чтобы оценивать корректность и время работы алгоритмов.</p><h2>Оценка корректности</h2>
<p>Три основных способа:</p><ul>
<li>Доказательство по индукции</li>
<li>Доказательство по инварианту</li>
<li>Доказательство от противного</li>
</ul><h2>Оценка времени</h2><p>Дать оценку времени работы алгоритма $O(...)$. Также есть три способа:</p><ul>
<li>Прямой учет</li>
<li>Амортизационный анализ</li>
<li>Рекуррентный анализ</li>
</ul><h1>На примерах квадратичных сортировок</h1><p>Формально задача звучит следующим образом: дан массив из $n$ чисел, нужно отсортировать его за $O(n^2)$</p><p>TODO: здесь везде дописать оценку времени работы.</p>
<h3>Сортировка пузырьком</h3>
<p><em>Описание:</em>
Пока существуют два соседних элемента, которые нарушают порядок сортировки, алгоритм проходится по массиву от начала до конца и меняет их местами.</p>
<pre><code>for i: 1 to n
    for j: 1 to n-1
        if a[j] &gt; a[j + 1]
            swap(a[j], a[j + 1])
</code></pre>
<p>TODO: здесь дописать доказательство</p><h3>Сортировка выбором</h3>
<p><em>Описание:</em>
На $i$-ом шаге алгоритм проходится по массиву от первого элемента до элемента с индексом $n - i + 1$, выбирает из них максимальный и меняет местами с элементом с номером $n - i + 1$.</p>
<pre><code>for i: 0 to n - 1
    p: a[p] = max(a[1], a[2], ..., a[n - i])
    swap(a[p], a[n - i])
</code></pre>
<p><em>Доказательство по индукции:</em></p><ul>
<li>База: $n = 1$: массив из одного элемента уже отсортирован</li>
<li>Предположение: массив из $n$ элментов сортируется верно</li>
<li>Переход: выберем максимальный элемент и вставим его в конец, отсортируем первые $n$ элементов, по предположению они отсортируются верно $\Rightarrow$ массив из $n + 1$ элементов будет остортирован верно.</li>
</ul><h3>Сортировка вставкой</h3>
<p><em>Описание:</em>
Нa $i$-ом шаге первые $i$ элементов отсортированы. Рассмотрим $(i + 1)$-ый элемент и вставим его в первые $i$ элементов так, чтобы были отсортированы первые $i + 1$ элементов.</p><p><em>Доказательство по инварианту:</em></p><ul>
<li>Инвариант: после $i$ шагов первые $i$ элементов отсортированы</li>
<li>Переход: покажем, что после $i + 1$ шага первые  $i + 1$ элементов отсортированы. Мы так вставляем $(i + 1)$-ый элемент, что инвариант сохраняется.</li>
</ul>
  </div>

  <div id="footnote_container"></div>

  <div class="article_tail">
    <div class="article_authors">Belloid</div>
    <div class="article_date">1 Декабря 2020</div>
  </div>
</div>
