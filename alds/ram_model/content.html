<div class="article">
  <div class="article_header">RAM-модель</div>

  <div class="article_subheader"><tr>
    <table width=100% style="border-collapse:collapse"><tr>
      <td style="width:100%">
        <div class="article_parent">
          <a style="color:#283593" href=/alds>Алгоритмы и структуры данных</a>
        </div>
      </td>
      <td style="padding:0px">
        <img src="{% static "svg/clock.svg" %}" width=16px height=16px style="margin-right:10px"/>
      </td>
      <td nowrap="nowrap">
        <div class="article_reading_time">
          8 min
        </div>
      </td>
    </tr></table>
  </div>

  <div class="article_body">
    <h1>Word-RAM model</h1>
<p>Чтобы давать теоритическую оценку времени выполнения алгоритмов, нужно ввести строгую математическую модель. Будем использовать модель <strong>word-RAM</strong> (где <em>RAM</em> расшифровывается, как <em>Random Access Machine</em> или <em>машина с произвольным доступом</em>). Опишем особенности этой модели:</p><ol>
<li><strong><em>Один вычислитель</em></strong> = одно <span class="footnote_link" id="0" onclick='showFootnote("0")' footnote-title="Как на английском?" footnote-text="<p><em>англ. CPU - Central Processing Unit</em></p>"> <em>Центральное Процессорное Устройство (ЦПУ)</em> </span class="footnote_link" id="0" onclick='showFootnote("0")' footnote-title="Как на английском?" footnote-text="<p><em>англ. CPU - Central Processing Unit</em></p>"></li>
<li><strong><em>Бесконечная одноранговая память</em></strong>: содержит бесконечное количество ячеек, которые индексируются начиная с нуля. Каждая ячейка содержит либо <em>целое</em>, либо <em>вещественное</em> число, последнее хранится в экспоненциальном виде: $m \cdot 2^p$, где $m$ - мантисса числа.</li>
<li><span class="footnote_link" id="1" onclick='showFootnote("1")' footnote-title="Как на английском?" footnote-text="<p><em>англ. ALU - Arithmetic Logic Unit</em></p>"> <strong><em>Арифметико-логическое устройство (АЛУ)</em></strong> </span class="footnote_link" id="1" onclick='showFootnote("1")' footnote-title="Как на английском?" footnote-text="<p><em>англ. ALU - Arithmetic Logic Unit</em></p>">, которое поддерживает:<ul>
<li>Арифметические операции: $+, -, *, div, mod$</li>
<li>Логические операции: $&lt;, &gt;, ==$</li>
<li>Битовые операции: $&lt;&lt;, &gt;&gt;, and, or, xor$</li>
<li><em>Математические операции</em><em>: $sin, cos, atan2, \sqrt{ }$ (квадратный корень)
</em>$<em>$ - данные операции присутствуют в модели не всегда</em></li>
</ul>
</li>
<li><strong><em>Разрешены операции:</em></strong> $\textit{\textbf{if, goto, a[i]}}$</li>
<li><strong><em>Непрямая адресация</em></strong></li>
<li><strong><em>Операции выполняются за</em></strong> $\textit{\textbf{O(1)}}$</li>
</ol>
<p>Введем в нашу модель ограничения:</p>
<ol>
<li>
<p><strong><em>Размер чисел</em></strong></p>
<ul>
<li>Давайте представим, что <em>входные данные</em> - это последовательность из $n$ целых чисел $a_1, a_2,..., a_n$, которая <strong>непрерывно</strong> записана где-то в оперативной памяти. (<em>Выходные данные</em> тоже представим последовательностью чисел: на выходе будем предъявлять начало блока памяти, в котором записан ответ, и явно об этом сигнализировать.)</li>
<li>Пусть $С$ - некоторое ограничение на входные данные, то есть $C = max(a_1, a_2, ... , a_n)$</li>
<li>Тогда размер чисел будет ограничен $poly(C, n, t(n))$, где $t(n)$ - время работы алгоритма.</li>
<li>Слово <em>"word"</em> в названии <strong>word-Ram</strong> обозначает, что у нас появляется дополнительный параметр $w$ - размер чисел, с которыми можно оперировать, что позволяет использовать битовые операции.</li>
</ul>
</li>
<li>
<p><strong><em>Память</em></strong></p>
<ul>
<li>Память бесконечная, но ограничим количество ячеек, которые можно использовать, $t(n)$. Пусть $num$ - максимальный номер ячейки памяти, которую мы будем использовать тогда должно быть выполнено: $$\exists \bar c: num \leq \bar c \cdot t(n)$$</li>
</ul>
</li>
</ol>
<h1>Оценка корректности алгоритмов</h1>
<p>Когда мы предъявляем алгоритм для решения какой-либо задачи мы должны:</p>
<ul>
<li>Доказать, что этот алгоритм решает поставленную задачу. Есть три способа сделать это:<ol>
<li>Доказательство по индукции</li>
<li>Доказательство по инварианту</li>
<li>Доказательство от противного</li>
</ol>
</li>
<li>Дать оценку времени работы алгоритма $O(n)$. Также есть три способа:<ol>
<li>Прямой учет</li>
<li>Амортизационный анализ</li>
<li>Анализ рекуррент</li>
</ol>
</li>
</ul>
<h1>Сортировки</h1>
<p><strong>ЗАДАЧА:</strong> дан массив из $n$ чисел, нужно отсортировать его за $O(n^2)$</p>
<h3>Сортировка пузырьком</h3>
<p><em>Описание:</em>
Пока существуют два соседних элемента, которые нарушают порядок сортировки, алгоритм проходится по массиву от начала до конца и меняет их местами.</p>
<p><em>Псевдокод:</em></p>
<pre><code>for i: 1 to n
    for j: 1 to n-1
        if a[j] &gt; a[j + 1]
            swap(a[j], a[j + 1]
</code></pre>
<h3>Сортировка выбором</h3>
<p><em>Описание:</em>
На $i$-ом шаге алгоритм проходится по массиву от первого элемента до элемента с индексом $n - i + 1$, выбирает из них максимальный и меняет местами с элементом с номером $n - i + 1$.</p>
<p><em>Псевдокод:</em></p>
<pre><code>for i: 0 to n - 1
    p: a[p] = max(a[1], a[2], ..., a[n - i])
    swap(a[p], a[n - i])
</code></pre>
<p><em>Доказательство по индукции:</em>
* База: $n = 1$: массив из одного элемента уже отсортирован
* Предположение: массив из $n$ элментов сортируется верно
* Переход: выберем максимальный элемент и вставим его в конец, отсортируем первые $n$ элементов, по предположению они отсортируются верно $\Rightarrow$ массив из $n + 1$ элементов будет остортирован верно.</p>
<h3>Сортировка вставкой</h3>
<p><em>Описание:</em>
Нa $i$-ом шаге первые $i$ элементов отсортированы. Рассмотрим $(i + 1)$-ый элемент и вставим его в первые $i$ элементов так, чтобы были отсортированы первые $i + 1$ элементов.</p>
<p><em>Доказательство по инварианту:</em>
* Инвариант: после $i$ шагов первые $i$ элементов отсортированы
* Переход: покажем, что после $i + 1$ шага первые  $i + 1$ элементов отсортированы. Мы так вставляем $(i + 1)$-ый элемент, что инвариант сохраняется.</p>
  </div>

  <div id="footnote_container"></div>

  <div class="article_tail">
    <div class="article_authors">Belloid</div>
    <div class="article_date">1 Декабря 2020</div>
  </div>
</div>
