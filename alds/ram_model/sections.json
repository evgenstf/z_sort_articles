[{
  "type":"tldr",
  "content":"RAM MODEL"
},
{"type":"markdown",
  "content":"# Word-RAM model \nЧтобы давать теоритическую оценку времени выполнения алгоритмов, нужно ввести строгую математическую модель. Будем использовать модель **word-RAM** (где *RAM* расшифровывается, как *Random Access Machine* или *машина с произвольным доступом*). Опишем особенности этой модели:\n \n1. ***Один вычислитель*** = одно <!*Центральное Процессорное Устройство (ЦПУ)*!>(Как на английском?){*англ. CPU - Central Processing Unit*} \n2. ***Бесконечная одноранговая память***: содержит бесконечное количество ячеек, которые индексируются начиная с нуля. Каждая ячейка содержит либо *целое*, либо *вещественное* число, последнее хранится в экспоненциальном виде: $m \\cdot 2^p$, где $m$ - мантисса числа. \n 3. <!***Арифметико-логическое устройство (АЛУ)***!>(Как на английском?){*англ. ALU - Arithmetic Logic Unit*}, которое поддерживает: \n\n  * Арифметические операции: $+, -, *, div, mod$\n  * Логические операции: $<, >, ==$ \n* Битовые операции: $<<, >>, and, or, xor$ \n* *Математические операции**: $sin, cos, atan2, \\sqrt{ }$ (квадратный корень) \n*$*$ - данные операции присутствуют в модели не всегда* \n4. ***Разрешены операции:*** $\\textit{\\textbf{if, goto, a[i]}}$ \n5. ***Непрямая адресация*** \n6. ***Операции выполняются за*** $\\textit{\\textbf{O(1)}}$\n \nВведем в нашу модель ограничения:\n \n1. ***Размер чисел*** \n* Давайте представим, что *входные данные* - это последовательность из $n$ целых чисел $a_1, a_2,..., a_n$, которая **непрерывно** записана где-то в оперативной памяти. (*Выходные данные* тоже представим последовательностью чисел: на выходе будем предъявлять начало блока памяти, в котором записан ответ, и явно об этом сигнализировать.) \n* Пусть $С$ - некоторое ограничение на входные данные, то есть $C = max(a_1, a_2, ... , a_n)$ \n* Тогда размер чисел будет ограничен $poly(C, n, t(n))$, где $t(n)$ - время работы алгоритма. \n * Слово *\"word\"* в названии **word-Ram** обозначает, что у нас появляется дополнительный параметр $w$ - размер чисел, с которыми можно оперировать, что позволяет использовать битовые операции.\n \n2. ***Память*** *\n Память бесконечная, но ограничим количество ячеек, которые можно использовать, $t(n)$. Пусть $num$ - максимальный номер ячейки памяти, которую мы будем использовать тогда должно быть выполнено: $$\\exist \\bar c: num \\leq \\bar c \\cdot t(n)$$\n \n# Оценка корректности алгоритмов \nКогда мы предъявляем алгоритм для решения какой-либо задачи мы должны:\n \n* Доказать, что этот алгоритм решает поставленную задачу. Есть три способа сделать это: \n1. Доказательство по индукции \n2. Доказательство по инварианту \n3. Доказательство от противного \n* Дать оценку времени работы алгоритма $O(n)$. Также есть три способа: \n1. Прямой учет \n2. Амортизационный анализ 3\n. Анализ рекуррент\n \n# Сортировки \n**ЗАДАЧА:** дан массив из $n$ чисел, нужно отсортировать его за $O(n^2)$ \n### Сортировка пузырьком \n*Описание:* \nПока существуют два соседних элемента, которые нарушают порядок сортировки, алгоритм проходится по массиву от начала до конца и меняет их местами.\n \n*Псевдокод:* `\n`` \nfor i: 1 to n \nfor j: 1 to n-1 \nif a[j] > a[j + 1] \nswap(a[j], a[j + 1] \n```\n \n### Сортировка выбором \n*Описание:* \nНа $i$-ом шаге алгоритм проходится по массиву от первого элемента до элемента с индексом $n - i + 1$, выбирает из них максимальный и меняет местами с элементом с номером $n - i + 1$.\n \n*Псевдокод:* \n``` \nfor i: 0 to n - 1 \np: a[p] = max(a[1], a[2], ..., a[n - i]) \nswap(a[p], a[n - i]) \n``` *\nДоказательство по индукции:* \n* База: $n = 1$: массив из одного элемента уже отсортирован \n* Предположение: массив из $n$ элментов сортируется верно \n* Переход: выберем максимальный элемент и вставим его в конец, отсортируем первые $n$ элементов, по предположению они отсортируются верно $\\Rightarrow$ массив из $n + 1$ элементов будет остортирован верно. \n ### Сортировка вставкой \n*Описание:* \nНa $i$-ом шаге первые $i$ элементов отсортированы. Рассмотрим $(i + 1)$-ый элемент и вставим его в первые $i$ элементов так, чтобы были отсортированы первые $i + 1$ элементов.\n \n*Доказательство по инварианту:* \n* Инвариант: после $i$ шагов первые $i$ элементов отсортированы \n* Переход: покажем, что после $i + 1$ шага первые  $i + 1$ элементов отсортированы. Мы так вставляем $(i + 1)$-ый элемент, что инвариант сохраняется." }]
