[{"type": "tldr", "content": "# Word-RAM model\nЧтобы давать теоритическую оценку времени выполнения алгоритмов, нужно ввести строгую математическую модель. Будем использовать модель **word-RAM** (где *RAM* расшифровывается, как *Random Access Machine* или *машина с произвольным доступом*). Опишем особенности этой модели:"}, {"type": "markdown", "content": " 1. ***Один вычислитель*** = одно <+ *Центральное Процессорное Устройство (ЦПУ)* +>(Как на английском?){*англ. CPU - Central Processing Unit*}\n2. ***Бесконечная одноранговая память***: содержит бесконечное количество ячеек, которые индексируются начиная с нуля. Каждая ячейка содержит либо *целое*, либо *вещественное* число, последнее хранится в экспоненциальном виде: $m \\cdot 2^p$, где $m$ - мантисса числа.\n3. <+ ***Арифметико-логическое устройство (АЛУ)*** +>(Как на английском?){*англ. ALU - Arithmetic Logic Unit*}, которое поддерживает:\n\t * Арифметические операции: $+, -, *, div, mod$\n\t * Логические операции: $<, >, ==$\n\t * Битовые операции: $<<, >>, and, or, xor$\n\t * *Математические операции**: $sin, cos, atan2, \\sqrt{ }$ (квадратный корень)\n\t*$*$ - данные операции присутствуют в модели не всегда*\n4. ***Разрешены операции:*** $\\textit{\\textbf{if, goto, a[i]}}$\n5. ***Непрямая адресация***\n6. ***Операции выполняются за*** $\\textit{\\textbf{O(1)}}$\n\nВведем в нашу модель ограничения:\n\n 1. ***Размер чисел***\n\t * Давайте представим, что *входные данные* - это последовательность из $n$ целых чисел $a_1, a_2,..., a_n$, которая **непрерывно** записана где-то в оперативной памяти. (*Выходные данные* тоже представим последовательностью чисел: на выходе будем предъявлять начало блока памяти, в котором записан ответ, и явно об этом сигнализировать.)\n\t * Пусть $С$ - некоторое ограничение на входные данные, то есть $C = max(a_1, a_2, ... , a_n)$\n\t * Тогда размер чисел будет ограничен $poly(C, n, t(n))$, где $t(n)$ - время работы алгоритма.\n\t * Слово *\"word\"* в названии **word-Ram** обозначает, что у нас появляется дополнительный параметр $w$ - размер чисел, с которыми можно оперировать, что позволяет использовать битовые операции.\n\n 2. ***Память***\n\t  * Память бесконечная, но ограничим количество ячеек, которые можно использовать, $t(n)$. Пусть $num$ - максимальный номер ячейки памяти, которую мы будем использовать тогда должно быть выполнено: $$\\exists \\bar c: num \\leq \\bar c \\cdot t(n)$$\n\n# Оценка корректности алгоритмов\nКогда мы предъявляем алгоритм для решения какой-либо задачи мы должны:\n\n * Доказать, что этот алгоритм решает поставленную задачу. Есть три способа сделать это:\n\t1. Доказательство по индукции\n\t2. Доказательство по инварианту\n\t3. Доказательство от противного\n * Дать оценку времени работы алгоритма $O(n)$. Также есть три способа:\n\t 1. Прямой учет\n\t 2. Амортизационный анализ\n\t 3. Анализ рекуррент\n\n# Сортировки\n**ЗАДАЧА:** дан массив из $n$ чисел, нужно отсортировать его за $O(n^2)$\n### Сортировка пузырьком\n*Описание:*\nПока существуют два соседних элемента, которые нарушают порядок сортировки, алгоритм проходится по массиву от начала до конца и меняет их местами.\n\n*Псевдокод:*\n```\nfor i: 1 to n\n\tfor j: 1 to n-1\n\t\tif a[j] > a[j + 1]\n\t\t\tswap(a[j], a[j + 1]\n```\n\n### Сортировка выбором\n*Описание:*\nНа $i$-ом шаге алгоритм проходится по массиву от первого элемента до элемента с индексом $n - i + 1$, выбирает из них максимальный и меняет местами с элементом с номером $n - i + 1$.\n\n*Псевдокод:*\n```\nfor i: 0 to n - 1\n\tp: a[p] = max(a[1], a[2], ..., a[n - i])\n\tswap(a[p], a[n - i])\n```\n*Доказательство по индукции:*\n* База: $n = 1$: массив из одного элемента уже отсортирован\n* Предположение: массив из $n$ элментов сортируется верно\n* Переход: выберем максимальный элемент и вставим его в конец, отсортируем первые $n$ элементов, по предположению они отсортируются верно $\\Rightarrow$ массив из $n + 1$ элементов будет остортирован верно.\n### Сортировка вставкой\n*Описание:*\nНa $i$-ом шаге первые $i$ элементов отсортированы. Рассмотрим $(i + 1)$-ый элемент и вставим его в первые $i$ элементов так, чтобы были отсортированы первые $i + 1$ элементов.\n\n*Доказательство по инварианту:*\n* Инвариант: после $i$ шагов первые $i$ элементов отсортированы\n* Переход: покажем, что после $i + 1$ шага первые  $i + 1$ элементов отсортированы. Мы так вставляем $(i + 1)$-ый элемент, что инвариант сохраняется.\n"}]