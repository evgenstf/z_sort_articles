[
  {
    "content": "Для теоретической оценки корректности и времени выполнения алгоритмов, будем использовать строгую математическую модель алгоритмической машины **word-RAM**, на которой они запускаются. В этом конспекте разбираемся с ее формальным определением, способами оценок, разбираем на примере квадратичных сортировок.",
    "type": "tldr"
  },
  {
    "content": "",
    "type": "markdown"
  },
  {
    "content": "# Устройство модели\nСначала стоит проговорить, что термин **word-RAM** расшифровывается как *word random access machine*, где *random access* означает возможность <+произвольного доступа к любой ячейки памяти+>(А бывает по-другому?){Да, например последовательная память, в которой для доступа к ячейки памяти сначала нужно прочитать все предыдущие.}, а *word* означает явное определение длины слова $w$, которым оперирует машина (например, байт -- 8 бит).",
    "type": "markdown"
  },
  {
    "content": "## Архитектура\nМодель состоит из трех компонент:",
    "type": "markdown"
  },
  {
    "content": "![RAM Model Diagram]({% static 'articles/alds/ram_model/diagram_0.svg' %})",
    "type": "markdown"
  },
  {
    "content": " 1. **Однопоточный CPU** -- устройство, в  единственном потоке последовательно выполняющее команды.\n 2. **Бесконечная одноранговая память** -- индексируемый с нуля набор ячеек, содержащих целые либо вещественные числа. Вещественные числа хранятся в экспоненциальном виде: $m \\cdot 2^p$, где $m$ - мантисса числа. *Поддерживает **непрямую адресацию** -- возможность хранить в ячейке памяти указатель на другую ячейку памяти и разыменовывать его.*\n 3. **Арифметико-логическое устройство (ALU)** -- в нашем контексте набор простейших арифметических операций:\n\t* Присутствуют всегда\n\t\t* Арифметические операции: $+, -, *, div, mod$\n\t\t* Логические операции: $<, >, ==$\n\t* Находятся в <+\"серой зоне\"+>(Что это?){Набор операций, зависящий от длины слова $w$. В некоторых задачах может быть явно запрещен. }\n\t\t* Битовые операции: $<<, >>, and, or, xor$\n\t\t* Математические операции: $sin(x), cos(y), atan2(y, x), \\sqrt{x}$ ...",
    "type": "markdown"
  },
  {
    "content": "## Команды\nПрограмма, исполняемая CPU может храниться отдельно от данных (так называемая [Гарвардская архитекутра](https://en.wikipedia.org/wiki/Harvard_architecture)) или же быть их частью ([архитектура Фон Неймана](https://en.wikipedia.org/wiki/Von_Neumann_architecture)).",
    "type": "markdown"
  },
  {
    "content": "Набор доступных команд ограничен:",
    "type": "markdown"
  },
  {
    "content": "* **ALU(...)** -- арифметическая операция над операндами\n* **a[i]** -- обращение к памяти (разыменование $i$-ой ячейки)\n* **jmp *n*** -- безусловный переход к $n$-ой команде\n* **if *condition* then *n*** -- условный переход к $n$-ой команде\n* **rnd *x*** -- возможность получить случайное число от $0$ до $x$",
    "type": "markdown"
  },
  {
    "content": "*Все операции выполняются за константное время $O(1)$*",
    "type": "markdown"
  },
  {
    "content": "## Ограничения используемой памяти",
    "type": "markdown"
  },
  {
    "content": "Главное соображение, которым мы руководствуемся вводя его, в том, чтобы алгоритм не мог использовать физическую бесконечность памяти для решения задачи.",
    "type": "markdown"
  },
  {
    "content": "Общее количество используемых ячеек памяти должно быть полиномиально ограниченно относительно размера входных данных.",
    "type": "markdown"
  },
  {
    "content": "Для этого потребуется два формальных ограничения:",
    "type": "markdown"
  },
  {
    "content": "* ***На размер чисел*** -- максимальное число, которое может использовать алгоритм не должно превышать полинома от\n\t* $C$ -- максимального числа из входных данных\n\t*  $n$ --  размера входных данных\n\t* $t(n)$ -- времени работы алгоритма (*этот компонент необходим в случаях, когда время работы превышает полином от $n$*)\n* ***На ячейки памяти*** -- количество используемых ячеек памяти не должно превышать полинома от $t(n)$",
    "type": "markdown"
  },
  {
    "content": "# Анализ алгоритмов\nУсловностей выше достаточно, чтобы оценивать корректность и время работы алгоритмов.",
    "type": "markdown"
  },
  {
    "content": "## Оценка корректности\nТри основных способа:",
    "type": "markdown"
  },
  {
    "content": "* Доказательство по индукции\n* Доказательство по инварианту\n* Доказательство от противного",
    "type": "markdown"
  },
  {
    "content": "\n## Оценка времени",
    "type": "markdown"
  },
  {
    "content": " Дать оценку времени работы алгоритма $O(...)$. Также есть три способа:",
    "type": "markdown"
  },
  {
    "content": "* Прямой учет\n* Амортизационный анализ\n* Рекуррентный анализ",
    "type": "markdown"
  },
  {
    "content": "# На примерах квадратичных сортировок",
    "type": "markdown"
  },
  {
    "content": "Формально задача звучит следующим образом: дан массив из $n$ чисел, нужно отсортировать его за $O(n^2)$",
    "type": "markdown"
  },
  {
    "content": "\nTODO: здесь везде дописать оценку времени работы.\n### Сортировка пузырьком\n*Описание:*\nПока существуют два соседних элемента, которые нарушают порядок сортировки, алгоритм проходится по массиву от начала до конца и меняет их местами.\n```\nfor i: 1 to n\n\tfor j: 1 to n-1\n\t\tif a[j] > a[j + 1]\n\t\t\tswap(a[j], a[j + 1])\n```\nTODO: здесь дописать доказательство",
    "type": "markdown"
  },
  {
    "content": "### Сортировка выбором\n*Описание:*\nНа $i$-ом шаге алгоритм проходится по массиву от первого элемента до элемента с индексом $n - i + 1$, выбирает из них максимальный и меняет местами с элементом с номером $n - i + 1$.\n```\nfor i: 0 to n - 1\n\tp: a[p] = max(a[1], a[2], ..., a[n - i])\n\tswap(a[p], a[n - i])\n```\n*Доказательство по индукции:*",
    "type": "markdown"
  },
  {
    "content": "* База: $n = 1$: массив из одного элемента уже отсортирован\n* Предположение: массив из $n$ элментов сортируется верно\n* Переход: выберем максимальный элемент и вставим его в конец, отсортируем первые $n$ элементов, по предположению они отсортируются верно $\\Rightarrow$ массив из $n + 1$ элементов будет остортирован верно.",
    "type": "markdown"
  },
  {
    "content": "\n### Сортировка вставкой\n*Описание:*\nНa $i$-ом шаге первые $i$ элементов отсортированы. Рассмотрим $(i + 1)$-ый элемент и вставим его в первые $i$ элементов так, чтобы были отсортированы первые $i + 1$ элементов.",
    "type": "markdown"
  },
  {
    "content": "*Доказательство по инварианту:*",
    "type": "markdown"
  },
  {
    "content": "* Инвариант: после $i$ шагов первые $i$ элементов отсортированы\n* Переход: покажем, что после $i + 1$ шага первые  $i + 1$ элементов отсортированы. Мы так вставляем $(i + 1)$-ый элемент, что инвариант сохраняется.\n",
    "type": "markdown"
  }
]