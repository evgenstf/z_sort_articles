**Дерево отрезков** *(англ. Segment tree)* — это структура данных, которая позволяет за асимптотику $O(\log n)$ реализовать любые операции, определяемые на множестве, на котором данная операция ассоциативна, и существует нейтральный элемент относительно этой операции, то есть на моноиде. Например, суммирование на множестве натуральных чисел, поиск минимума на любом числовом множестве, перемножение матриц на множестве матриц размера $N*N$, объединение множеств, поиск наибольшего общего делителя на множестве целых чисел и многочленов.

При этом дополнительно возможно изменение элементов массива: [как изменение значения одного элемента](https://google.com), так и изменение элементов на целом подотрезке массива, например разрешается присвоить всем элементам $a[l…r]$ какое-либо значение, либо прибавить ко всем элементам массива какое-либо число. Структура занимает $O(n)$ памяти, а ее построение требует $O(n)$ времени.

## Структура

Структура представляет собой дерево, листьями которого являются элементы исходного массива. Другие вершины этого дерева имеют по $2$ ребенка и содержат результат операции от своих детей (например минимум или сумму). Таким образом, корень содержит результат искомой функции от всего массива $[0…n−1]$, левый ребёнок корня содержит результат функции на $[0…\frac{n}{2}]$, а правый, соответственно результат на $[\frac{n}{2}+1\ldots n−1]$. И так далее, продвигаясь вглубь дерева.

![Segment Tree](https://neerc.ifmo.ru/wiki/images/c/c4/Segment_tree.png)

## Построение дерева

Пусть исходный массив a состоит из n элементов. Для удобства построения увеличим длину массива a так, чтобы она равнялась ближайшей степени двойки, т.е. $2k$, где $2k>n$. Это сделано, для того чтобы не допустить обращение к несуществующим элементам массива при дальнейшем процессе построения. Пустые элементы необходимо заполнить нейтральными элементами моноида. Тогда для хранения дерева отрезков понадобится массив $t$ из $2k+1$ элементов, поскольку в худшем случае количество вершин в дереве можно оценить суммой $n+\frac{n}{2}+\frac{n}{4}\ldots+1<2n$, где $n=2k$. Таким образом, структура занимает линейную память.

Процесс построения дерева заключается в заполнении массива $t$. Заполним этот массив таким образом, чтобы i-й элемент являлся бы результатом некоторой бинарной операции (для каждой конкретной задачи своей) от элементов c номерами $2i+1$ и $2i+2$, то есть родитель являлся результатом бинарной операции от своих сыновей (обозначим в коде эту операцию как "∘"). Один из вариантов — делать рекурсивно. Пусть у нас имеются исходный массив a, а также переменные $t_l$ и $t_r$, обозначающие границы текущего полуинтервала. Запускаем процедуру построения от корня дерева отрезков $(i=0, tl=0, tr=n)$, а сама процедура построения, если её вызвали не от листа, вызывает себя от каждого из двух сыновей и суммирует вычисленные значения, а если её вызвали от листа — то просто записывает в себя значение этого элемента массива (Для этого у нас есть исходный массив $a$). Асимптотика построения дерева отрезков составит, таким образом, $O(n)$.

Выделяют два основных способа построения дерева отрезков: построение снизу и построение сверху. При построении снизу алгоритм поднимается от листьев к корню (Просто начинаем заполнять элементы массива $t$ от большего индекса к меньшему, таким образом при заполнении элемента $i$ его дети $2i+1$ и $2i+2$ уже будут заполнены, и мы с легкостью посчитаем бинарную операцию от них), а при построении сверху спускается от корня к листьям. Особенные изменения появляются в реализации запросов к таким деревьям отрезков.

$$
\frac{1}{2}
$$

$$\frac{\sum_{i=1}^\infty \frac{1}{i^2}}{ \int_{-\infty}^\infty
   \frac{1}{\sqrt{2\pi\sigma^2}} \exp\bigl(-\frac{(x-\mu)^2}{2\sigma^2}\bigr)
   \,\mathrm{d}x} = \frac{\pi^2}{6}$$

$$
\frac{\sum_{i=1}^\infty \frac{1}{i^2}}{\int_{-\infty}^\infty
   \frac{1}{\sqrt{2\pi\sigma^2}} \exp\biggl(-\frac{(x-\mu)^2}{2\sigma^2}\biggr)
   \,\mathrm{d}x} = \frac{\pi^2}{6}
$$
